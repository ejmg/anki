* swe
  :PROPERTIES:
  :ANKI_DECK: swe
  :END:
* data structures
  :PROPERTIES:
  :ANKI_DECK: data structures and algorithms
  :END:
** Linked Lists
*** Singly Linked List Insertion Front
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Basic
    :ANKI_NOTE_ID: 1566509133926
    :END:
**** Front
     What is the time-complexity of insertion at the front of a singly linked list?
**** Back
     - by definition of a singly linked list, have a reference to the head node...
     - Insertion at front: $\Theta(1)$
*** Singly Linked List Deletion Front
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Basic
    :ANKI_NOTE_ID: 1566509134126
    :END:
**** Front
     What is the time-complexity of deletion at the front of a singly linked list?
**** Back
     - by definition of a singly linked list, have a reference to the head node...
     - Deletion at front: $\Theta(1)$
*** Singly Linked List Arbitrary Insertion
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Basic
    :ANKI_NOTE_ID: 1566509134176
    :END:
**** Front
     What is the time-complexity of an arbitrary insertion for a singly linked list?
**** Back
     - time-complexity of finding the node: $\mathcal{O}(n)$
     - insertion with a known reference to node: $\Theta(1)$
     - thus: $\mathcal{O}(n)$
*** Singly Linked List Append
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Basic
    :ANKI_NOTE_ID: 1566509134225
    :END:
**** Front
     What is the time-complexity of appending to a singly linked list?
**** Back
     - must iterate through all =next= node's till the end is found...
     - Thus, appending: $\mathcal{O}(n)$
** ADTs
*** Def of FIFO                                                        :Wiki:
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Cloze
    :ANKI_NOTE_ID: 1566332219243
    :END:
**** Text
     {{c1:: *FIFO*}} is an acronym for {{c2:: *First-In-First-Out*}}, a method for organizing and
     manipulating data where the {{c2::oldest (first) entry is processed first}}.
**** Extra
*** def of LIFO                                                        :Wiki:
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Cloze
    :ANKI_NOTE_ID: 1566849695055
    :END:
**** Text
     {{c1:: *LIFO* }} is an acronym for {{c2:: *Last-In-First-Out*,}} a method for
     organizing and manipulating data where the {{c2::newest (last) entry is
     processed first}}.
**** Extra
*** Average wait time of FIFO vs LIFO                                :Skiena:
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Basic
    :ANKI_NOTE_ID: 1566849695129
    :END:
**** Front
     Average wait time of a LIFO based data structure vs FIFO?
**** Back
     the average wait time for an element in a FIFO data structure vs FIFO is
     *the same*; however, LIFO *minimizes* the *maximum wait time*.
*** Def of stack ADT                                                   :Wiki:
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Cloze
    :ANKI_NOTE_ID: 1566849695180
    :END:
**** Text
     a {{c1::stack}} is a collection of elements which are {{c2::added and
     removed}} from {{c1::the "top" of}} the collection. The two principle
     operations are {{c2::push, which adds an element to the collection,}} and
     {{c2::pop, which removes the most recently added element.}}. This behavior
     gives a {{c1::stack}} its other name, {{c1:: *LIFO*, Last-In-First-Out}}.
**** Extra
*** def of dictionary ADT                                              :Wiki:
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Cloze
    :ANKI_NOTE_ID: 1566849695230
    :END:
**** Text
     an {{c1::associative array (AKA map, symbol table, or dictionary)}} is an
     abstract data type composed of a {{c2::collection of *(key, value) pairs*}}, such
     that {{c1::each possible key appears at most once in the collection}}.
**** Extra
*** operations of a dictionary ADT                              :Skiena:Wiki:
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Basic
    :ANKI_NOTE_ID: 1566849695305
    :END:
**** Front
     What are the operations for the dictionary ADT?
**** Back
     For dictionary =D=:
     - =search(k)=: given a search key =k=, return a pointer to the element
       whose key value is =k=.
     - =insert(x)=: given a data item =x=, add it to the dictionary.
     - =delete(k)=: given a key =k=, delete the value associated to it if it
       exists.
*** Def of Queue ADT                                                   :Wiki:
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Cloze
    :ANKI_NOTE_ID: 1566332219343
    :END:
**** Text
     A {{c1::queue}} is a {{c2::collection}} in which the entities are
     {{c1::kept in order}} and the principal operations on the {{c2::collection}} are
     the addition of entities to {{c2::the rear terminal position, known as
     *enqueue*}}, and removal of entities from {{c2::the front terminal position, known
     as *dequeue*}}. This makes the {{c1::queue}} a {{c2:: *First-In-First-Out (FIFO)* data
     structure}}.
**** Extra
*** Queue use cases
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Basic
    :ANKI_NOTE_ID: 1566332219168
    :END:
**** Front
     Example use cases for queues?
**** Back
     - asynchronous processes
       - message queue (mail servers, sending tweets, uploading content)
       - cpu scheduling
     - breadth-first search
     - literally anything where queuing theory may be applicable, (lines, first
       come first serve situations)
       - i.e. generally where order matters, whether because of fairness or
         technical...
*** Queue Insertion/Deletion                                           :Wiki:
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Basic
    :ANKI_NOTE_ID: 1566332219293
    :END:
**** Front
     time complexity of insert (enqueue) and delete (dequeue) for a queue?
**** Back
     both insert and deletion are $\Theta(1)$ for the standard definition of
     the operations of a FIFO structure.
*** Stack use cases                                                    :Wiki:
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Basic
    :ANKI_NOTE_ID: 1566849695631
    :END:
**** Front
     Use cases for stack data structures?
**** Back
     - Expression evaluation, parsing
       - postfix notation evaluator
       - CFG based languages can run on stack machines
     - Backtracking
       - error trace
       - depth-first search
     - compile time memory management
       - when we know the memory allocations at compile time, can maximize
         data locality
       - call stack for function and routines
*** Stack Pop/Push                                                     :Wiki:
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Basic
    :ANKI_NOTE_ID: 1566849695681
    :END:
**** Front
     time complexity of pop and push for the stack ADT?
**** Back
     both pop and push are $\Theta(1)$ for the standard definition of a Stack ADT.
** contiguous and linked data structures                             :Skiena:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1566849695730
   :END:
*** Front
    in terms of memory layout, what two categories can data structures be
    classified into?
*** Back
    1. Contiguously-Allocated
    2. Linked
** def contiguous data structure                                     :Skiena:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Cloze
   :ANKI_NOTE_ID: 1566849695780
   :END:
*** Text
    {{c1::Contiguously-allocated}} data structures are composed of {{c1::single slabs of
    memory}}, and include {{c2::arrays, matrices, heaps, and hash-tables}}.
*** Extra
** linked data structure                                             :Skiena:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Cloze
   :ANKI_NOTE_ID: 1566849695830
   :END:
*** Text
    {{c1::Linked}} data structures are composed of {{c1::distinct chunks of memory bound
    together by pointers}}, and include {{c2::lists, trees, and graph adjacency lists}}.
*** Extra
* rust
  :PROPERTIES:
  :ANKI_DECK: rust
  :END:
** Basic Pointer Types                                             :RustBook:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1566234808011
   :END:
*** Front
    rust's basic pointer types?
*** Back
    - =&T= and =&mut T=
    - =*const T= and =*mut T=
** Smart Pointer Types                                             :RustBook:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1566234808230
   :END:
*** Front
    rust's smart pointer types?
*** Back
    There are many, but the core smart pointers provided by =std= include:
    - =Box<T>=
    - =Rc<T>=
    - =Ref<T>= and =RefMut<T>=
      - accessed through =RefCell<T>=, do not conflate...
** Rc<T> smart pointer                                             :RustBook:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Cloze
   :ANKI_NOTE_ID: 1566234897086
   :END:
*** Text
**** Definition
     =Rc<T>= is a {{c1::reference counted pointer}}. In other words, this lets
     us have {{c1::multiple "owning" pointers to the same data}}, and the data
     will be dropped (destructors will be run) when {{c1::all pointers are out
     of scope}}. The pointers only have {{c1::immutable access}}, however.
**** Guarantees
     - main guarantee: {{c2::the data will not be destroyed}} until all references to it are out of scope.
**** Cost
     - first major smart pointer with {{c3::a run-time}} cost (=Box<T>=, =&T/&mut T=,
       =*const/*mut T= don't)
     - is a {{c3::single allocation}}, though it will {{c3::allocate two extra
       words ("strong" and "weak" ref counts)}}
     - computation cost of {{c3::incrementing/decrementing the refcount}}
       whenever it is {{c3::cloned}} or {{c3::goes out of scope}} respectively
**** Usage
     - When you wish to {{c4::dynamically allocate and share some data}} (read-only)
       between various portions of your program and...
       - it is not certain which portion {{c4::will finish using the pointer last}}.
       - viable alternative to {{c4::&T when &T}} is either impossible to statically
         check for correctness, {{c4::or creates extremely unergonomic code}}
*** Extra
** Box smart pointer                                               :RustBook:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Cloze
   :ANKI_NOTE_ID: 1566332221744
   :END:
*** Text
**** Definition
     Box<T> is an {{c1::"owned"}} pointer, or {{c1::a "box"}}. While it can
     hand out references to the contained data, it is {{c1::the only owner of
     the data}}.

     When a box (that hasn't been moved) goes out of scope, {{c1::destructors are
     run}}.
**** Cost
     - {{c2::a zero-cost abstraction}} for dynamic allocation
**** Usage
     - want to {{c3::allocate some memory on the heap}} and {{c3::safely pass around a pointer}} to that memory
*** Extra

** standard rules of ownership                                     :RustBook:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1566509136601
   :END:
*** Front
    What are rust's basic rules of Ownership?
*** Back
    - the owner of a value is a variable.
    - at any given moment, only a single owner is allowed.
    - the value is lost the moment the owner goes out of scope?
** nested structures with uncertain size in rust                      :hodsa:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1566509137902
   :END:
*** Front
    Why does the following not compile and what correction would allow it to?
    #+BEGIN_SRC rust
      struct Node {
          value: i32,
          next: Option<Node>,
      }
      struct LinkedList {
          head: Option<Node>,
          tail: Option<Node>,
          pub length: usize,
      }
    #+END_SRC
*** Back
    The code does not compile because struct =Node= is recursive with a heap
    allocated value, i.e. a value of uncertain and growable size. Technically,
    we fit the entire linked list in the first Node reference. Adding some
    indirection via a smart pointer, however, allows the compiler to relax and
    compile. This will compile.

    #+BEGIN_SRC rust
      struct Node {
          value: i32,
          next: Option<Rc<RefCell<Node>>>,
      }
      struct LinkedList {
          head: Option<Rc<RefCell<Node>>>,
          tail: Option<Rc<RefCell<Node>>>,
          pub length: usize,
      }
    #+END_SRC

    Even better would be to make a type alias for a link and use in place, a la:

    #+BEGIN_SRC rust
      type Link = Option<Rc<RefCell<Node>>>;
    #+END_SRC

** interior mutability pattern, top level definition/descriptive   :RustBook:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1566509137976
   :END:
*** Front
    What is the interior mutability pattern (top level definition/description)?
*** Back
    Interior mutability is a design pattern in Rust that allows you to mutate
    data even when there are immutable references to that data; normally, this
    action is disallowed by the borrowing rules.

    In Rust, such an action is enabled/encouraged via its safe API with types
    such as =RefCell<T>=.
** interior mutability pattern, short def                          :RustBook:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1566509138026
   :END:
*** Front
    What is the interior mutability pattern (short definition)?
*** Back
    Mutating the value inside an immutable value is the interior mutability
    pattern.

** How does =RefCell= allow interior mutability?                   :RustBook:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1566509138100
   :END:
*** Front
    How does =RefCell= enable interior mutability?
*** Back
    =RefCell<T>= allows us to wrap a value that, following the borrowing rules
    of rust, would not be mutable otherwise. This occurs through its methods, =.borrow()= and
    =.borrow_mut()=, which return the smart pointers =Ref<T>= and =RefMut<T>=,
    respectively.

    The =RefCell<T>= keeps track of how many =Ref<T>= and =RefMut<T>= smart pointers
    are currently active, and if a violation of rust's borrow rules is detected,
    will *panic* during run-time.
   
** =self= vs =Self=                                           :StackExchange:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1566509138151
   :END:
*** Front
    What is the difference between =self= vs =Self=?
*** Back
    =self= when used as the first argument to define a function of a type as a
    /method/, abd is a shorthand for =self: Self=.

    =Self= is the type of the current object and is often used as syntactic
    sugar in =Trait= definitions for the receiving (implementing) type, which is
    unknown to the author of the =Trait= being written.
** =self=                                                     :StackExchange:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Cloze
   :ANKI_NOTE_ID: 1566509138200
   :END:
*** Text
    {{c1::=self=}} is the name used in a trait or an impl for the first argument
    of a method.  There is no implicit =This= in Rust, and thus you must pass
    {{c1::=self=}} as an argument (and declare {{c1::=self= as a parameter for
    said argument}}) for a function to be a method of a type.
*** Extra
** why use the interior mutability pattern?                        :RustBook:
   :PROPERTIES:
   :ANKI_NOTE_TYPE: Basic
   :ANKI_NOTE_ID: 1566509138250
   :END:
*** Front
    Why is the interior mutability pattern used? Put differently, why does it
    exist?
*** Back
    The advantage of checking the borrowing rules at runtime instead is that
    certain memory-safe scenarios are then allowed, whereas they are disallowed
    by the compile-time checks. 

    Static analysis, like the Rust compiler, is inherently conservative. Some
    properties of code are impossible to detect by analyzing the code. Interior
    mutability gives us the ability to modify what we, as the programmer, know
    is a value safe for mutation in a given situation.
* TODO cards/topics
** rust
*** def of iterators 
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Cloze
    :ANKI_FAILURE_REASON: No deck specified
    :END:
**** Front
     Definition of iterators?
**** Back
*** Trait vs Impl 
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Basic
    :ANKI_FAILURE_REASON: No deck specified
    :END:
**** Front
**** Back
*** =Trait= vs Types 
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Basic
    :ANKI_FAILURE_REASON: No deck specified
    :END:
**** Front
**** Back
** DSA
*** skip list 
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Cloze
    :ANKI_FAILURE_REASON: No deck specified
    :END:
**** Text
     A skip list...
**** Extra
*** insertion sort (description) 
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Basic
    :ANKI_FAILURE_REASON: No deck specified
    :END:
**** Front
     Describe insertion sort
**** Back
*** insertion sort (psuedocode) 
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Cloze
    :ANKI_FAILURE_REASON: No deck specified
    :END:
**** Text
     *Insertion Sort* pseudo code is as follows:
   
**** Extra
** TODO db
   - need to go through textbook and find stuff worth writing cards about, etc
   - go to [[cs470: intro to dbs]] deck in suspended for some material
* Example Image note
** Front
   Foo!
** Back
   Here's a demo image, but first, let's ensure it's composable with latex,
   $F = \frac{\vec{A}}{x^{2 \dot \cup C}}$
   #+BEGIN_EXPORT html
   <img src="https://i.imgur.com/YheHQPT.jpg"/>
   #+END_EXPORT
* no longer studying (suspended)
  :PROPERTIES:
  :ANKI_DECK: suspended
  :END:
** How I suspend things.
   1. Create =suspended= deck in anki client.
   2. move pre-existing decks under it that I don't want to study/spam my
      review count.
   3. Open card/deck browser, =b=
   4. view side bar, =Ctrl-Shft-R=
   5. Go to =suspended= deck, select all cards, =Ctrl-a=
   6. toggle suspend, =Ctrl-j=
      - =Due= column entries should now all have =()= surrounding the value,
        indicating suspended.
      - when viewing main menu on desktop/phone client, should show 0 cards to
        review.
** cs470: intro to dbs
   :PROPERTIES:
   :ANKI_DECK: intro to database systems
   :END:
*** ch1
**** def of db
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1581057696125
     :END:
***** Front
      definition of database
***** Back
      a collection of related data
**** def of data
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1581057696325
     :END:
***** Front
      Definition of data (with respect to databases)
***** Back
      known facts that can be recorded and have implicit meaning.
**** implicit properties of a db
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1581057696400
     :END:
***** Front
      implicit properties of a database
***** Back
      1. Universe of Discourse (AKA "miniworld")
         - the db represents some aspect of "real" world
      2. logically coherent collection of data with some inherent meaning
      3. Design, built, and populated with data for specific purpose
         - has intended users, some idea of applications that will use it.
**** def of dbms
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1581057696500
     :END:
***** Front
      definition of database management system
***** Back
      general purpose software that facilitates the process of defining, constructing, manipulating,
      and sharing database(s) among various users and applications
**** def of dbs
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1581057696600
     :END:
***** Front
      definition of database system
***** Back
      a database(s) and database management system, together.

      [[file:img/dbs.jpg]]
**** Characteristics of db approach
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1581061816250
     :END:
***** Front
      main characteristics of database approach versus file-processing
***** Back
      1. self-describing nature of database system
      2. insulation between programs and data, and data abstraction
      3. support of multiple views
      4. sharing of data and multiuser transaction processing
**** self describing nature
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1581061815875
     :END:
***** Text
      the {{c1::self-describing nature of database systems}} means that {{c2::database system
           contains the database itself but also a complete definition and description of the
           database(s)'s structures, type/storage format of data items, and constraints as meta-data
           in the database systems' catalog}}

      4. sharing of data and multiuser transaction processing
***** Extra
**** insulation between program/data, and data abstraction
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1581061815975
     :END:
***** Text
      {{c1::insulation between programs and data}} is possible because of {{c2::program-data independence}}
      and {{c2::program-operation independence}} which is only made possible by the {{c2::data abstraction}} provided
      by the database approach.
***** Extra
**** why support for different views
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1581061881400
     :END:
***** Front
      what does the database approach require support for different views?
***** Back
      databases have different users with different needs and privileges with respect to data in the
      database, so the ability to provide different subsets of the same database data to different
      users is a critical function provided by databases.
**** sharing data & multiuser processing
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1581061816076
     :END:
***** Text
      the database approach includes {{c1::sharing data and multiuser processing}} by providing its
      own {{c2::concurrency controls}} to ensure {{c2::concurrent transactions over the same data}}
      execute {{c1::efficiently and correctly}}.
***** Extra
**** db design phases
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1581061816300
     :END:
***** Front
      phases of database design
***** Back
      1. Requirements Specification and Analysis
      2. Conceptual Design
      3. Logical Design
      4. Physical Design
**** prog data indep
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1581616358307
     :END:
***** Text
      {{c1::Program Data Independence}} means the {{c2::structure of data files is stored in DBMS catalog}}
      separately from {{c2::access programs}}
***** Extra
**** prog operation indep
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1581616533932
     :END:
***** Text
      {{c1::Program-Operation Independence}} is means that because the {{c2::operation interface
      includes the operation name and data types of its arguments}} so that the {{c2::implementation can
      be changed without affecting the interface}}.
***** Extra
**** data abstr
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1581617435282
     :END:
***** Text
      In databases, {{c1::Data Abstraction}} allows for {{c2::program-data independence}} and
      {{c2::program-operation independence}} by using a {{c1::conceptual representation of
      data}}. This means the {{c3::suppression of details}} of data organization and storage while {{c3::highlighting of the
      essential features}} for an improved understanding of data.

***** Extra
**** conceptual representation
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1581617435452
     :END:
***** Text
      {{c1::Conceptual Representation of Data}} means that {{c2::not all details of how data is stored or how
      operations are implemented is shown}} when {{c1::modeling and representing data}}.
***** Extra
**** data model
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1581617435531
     :END:
***** Text
      {{c1::Data Models}} are the type of {{c2::data abstraction}} used to {{c1::provide conceptual representation}} 
***** Extra
**** 4 props of a transaction
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :END:
***** Front
      What are the four properties of a database transaction?
***** Back
      1. Atomicity
      2. Consistency
      3. Isolation
      4. Durability
*** ch2
**** data model ch2
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1581624762881
     :END:
***** Front
      What are Data Models and what do they facilitate?
***** Back
      - a collection of concepts that describe the structure of a database, which:
        + Provides means to achieve data abstraction, such as defining...
        + Basic operations, such as specifying retrievals and updates, and describing...
        + Dynamic aspect or behavior of a database application, which allows db designing to specify
          a set of valid operations allowed on db objects.
**** data model categories
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1581624762982
     :END:
***** Front
      What are the three primary data model categories?
***** Back
      1. High Level (Conceptual)
      2. Representational
      3. Low Level (Physical)
**** HL data model
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1581624763181
     :END:
***** Text
      {{c1::High-Level}}, aka {{c1::Conceptual}}, Data Models {{c2::closely model the way many users perceive data and
      interact with it}}.
***** Extra
**** Repr. data model
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1581624763230
     :END:
***** Text
      {{c1::Representational}} Data Models are an intermediate data model that are {{c2::easily understood by end
      users}} but also {{c2::concern how data is organized in computer storage}}.
***** Extra
**** LL data model
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1581624763281
     :END:
***** Text
      {{c1::Low-Level}}, aka {{c1::Physical}}, Data Models {{c2::describe the details of how data is
      essential features}} for an improved understanding of datastored on computer storage media}}.
***** Extra
**** components of conceptual data model
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1581624763355
     :END:
***** Front
      Conceptual data models use...
***** Back
      1. Entities
      2. Attributes
      3. Relationships
**** entity def
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1581624763410
     :END:
***** Text
      {{c1::Entities}} in the conceptual data model represent {{c2::real-world objects or concepts}}.
***** Extra
**** attrib def
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1581624763480
     :END:
***** Text
      {{c1::Attributes}} in the conceptual data model {{c2::further describe an entity by noting a property
      of interest that describes the entity}}.
***** Extra
**** conceptual relationship def
     {{c1::Relationships}} in the conceptual data model represent {{c2::an association among entities}}.
*** ch3
**** requirements & analysis phase
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1581100195984
     :END:
***** Text
      the {{c1::first phase}} of database design process is {{c2::Requirements Collection and
      Analysis}}, which {{c1::involves database designers interviewing prospective database users to
      understand and document data requirements​}}.
      - the results of this phase include {{c3::data requirements}} and {{c3::functional requirements}}
***** Extra
**** TODO conceptual design
**** TODO logical design
**** TODO physical design
*** ch5
*** ch20
**** ACID
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1581061890150
     :END:
***** Front
      ACID stands for
***** Back
      1. Atomicity
      2. Consistency
      3. Isolation
         1) Durability
**** atomicity
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1581061816399
     :END:
***** Text
      the transaction property of {{c1::Atomicity}} means a transaction is {{c2::an atomic unit of processing}}; it should either
      {{c2::be performed in its entirety}} or {{c2::not performed at all}}.
***** Extra
**** consistency
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1581061816450
     :END:
***** Text
      the transaction property of {{c1::Consistency (Preservation)}} means a {{c1::transaction should be
      consistency preserving}}, meaning that if it {{c2::is completely executed from beginning to end without
      interference}} from other transactions, it should take the database {{c2::from one consistent state to
      another}}.
***** Extra
**** isolation
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1581061816500
     :END:
***** Text
      the transaction property of {{c1::Isolation}} means a transaction should appear as though {{c2::it is
      being executed in isolation from other transactions}}, even though {{c2::many transactions are
      executing concurrently}}. That is, the execution of a transaction {{c2::should not be interfered with
      by any other transactions executing concurrently}}.
***** Extra
**** durability
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1581061816850
     :END:
***** Text
      the transaction property of {{c1::Durability (or Permanent)}} means the changes applied {{c2::to the database
      by a committed transaction must persist in the database}}. These changes must {{c4::not be lost because
      of any failure}}.
***** Extra

** haskell book
   :PROPERTIES:
   :ANKI_DECK: haskell_book
   :END:
*** CH1
**** the lambda in the lambda calculus
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1546835357160
     :END:
***** Text
      The lambda in lambda calculus is the greek letter 𝜆 used to {{c1::introduce, or
      abstract,}} arguments for {{c1::binding}} in an expression.
***** Extra
**** the lambda abstraction
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1546835357234
     :END:
***** Text
      A lambda abstraction is an {{c1::anonymous function or lambda term}}.  $(\lambda x.x + 1)$
      The {{c1::head}} of the expression, $\lambda x$., abstracts out the {{c1::term}} $x + 1$. We can apply it
      to any x and recompute different results for each x we applied the lambda to.
***** Extra
**** application
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1546877373875
     :END:
***** Text
      Application is how one {{c1::evaluates or reduces lambdas}}, which binds the
      {{c1::parameter}} to the {{c1::concrete argument}}. The {{c1::argument}} is what specific term the
      lambda was applied to. Computations are performed in lambda calculus by
      applying {{c2::lambdas}} to arguments until you run out of {{c2::applications}} to perform.
***** Extra
**** lambda calculus
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546878448425
     :END:
***** Front
      Definition of the Lambda Calculus?
***** Back
      Lambda calculus is a formal system for expressing programs in terms of
      abstraction and application.
**** Normal Order
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1546878384275
     :END:
***** Text
      {{c1::Normal order}} is a common evaluation strategy in lambda calculi.  {{c1::Normal
      order}} means evaluating (ie, applying or beta reducing) the {{c2::leftmost outermost}}
      lambdas first, evaluating terms {{c2::nested within}} after you've run out of arguments
      to apply.
***** Extra
**** Haskell and normal form evaluation
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546878384328
     :END:
***** Front
      Is Haskell code evaluated in normal order?
***** Back
      Normal order isn't how Haskell code is evaluated - it's call-by-need
      instead.
*** CH2
**** parameter
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1546882037500
     :END:
***** Text
      A {{c1::parameter, or formal parameter,}} represents a value that will be {{c2::passed
      to the function when the function is called}}. Thus, {{c1::parameters}} are usually
      {{c2::variables}}.
***** Extra
**** arguments
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1546882037550
     :END:
***** Text
      An {{c1::argument}} is an input value the function is applied to. A function's
      parameter is bound to an {{c1::argument}} when the function is applied to that
      argument.
***** Extra
**** expression
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1546882037675
     :END:
***** Text
      An {{c1::expression}} is a combination of symbols that conforms to syn- tactic
      rules and can be evaluated to some result.
***** Extra
**** components of Haskell expression?
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546882037725
     :END:
***** Front
      Components of Haskell expression?
***** Back
      In Haskell, an expression is a well-structured combination of constants,
      variables, and functions. While irreducible constants are technically
      expressions, we usually refer to those as “values”, so we usually mean
      “reducible expression” when we use the term expression
**** value in Haskell
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546882037775
     :END:
***** Front
      What is a /value/ in Haskell?
***** Back
      A value is an expression that cannot be reduced or evaluated any
      further. 2 * 2 is an expression, but not a value, whereas what it
      evaluates to, 4, is a value.
**** functions
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546882037826
     :END:
***** Front
      What is a function?
***** Back
      A function is a mathematical object whose capabilities are limited to
      being applied to an argument and returning a result. Functions can be
      described as a list of ordered pairs of their inputs and the resulting
      outputs, like a mapping.
*** CH3
**** Top Level Bindings
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1547064272357
     :END:
***** Text
      /Top Level Bindings/ (in Haskell) are bindings that {{c1::stand outside of any
      other declaration}}. The main feature of /top level/ bindings is that they
      can {{c1::be made available to other modules in or outside}} of your program.
***** Extra
**** Local Bindings
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1547064272431
     :END:
***** Text
      /Local Bindings/ are bindings {{c1::local to particular expressions}}. They cannot
      be {{c1::imported by other programs or modules}}.
***** Extra
**** Scope
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1547063637657
     :END:
***** Text
      /Scope/ is where a {{c1::variable referred to by name is valid}}.
***** Extra
**** Concatenation
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1547063637706
     :END:
***** Text
      /Concatenation/ is the {{c1::joining together of sequences}} of values. In Haskell,
      this is typically meant with respect to {{c1::the /list/, [],}} datatype.
***** Extra
**** types in Haskell
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1547063637731
     :END:
***** Text
      Types (aka Datatypes) in Haskell determine {{c1::what values are members of the
      type or that /inhabit/ the type}}. Unlike other languages, datatypes in
      Haskell by default {{c1::do not delimit the operations that can be performed on
      the data.}}
***** Extra
**** type (datatype)
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1547063637756
     :END:
***** Text
      A /type/ (or /datatype/) is a {{c1::classification of values or data}}.
***** Extra
**** Strings in Haskell
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1547063637782
     :END:
***** Text
      A /String/ is a {{c1::sequence of characters}}. In Haskell, =String= is represented
      by a {{c1::linked-list of =Char=}} values, aka =[Char]=.
***** Extra
*** CH4
**** types of polymorphism in Haskell
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1547089995068
     :END:
***** Front
      Types of polymorphism in Haskell
***** Back
      Polymorphism in Haskell is either /Parametric/ or /Constrained/.
**** polymorphism
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1547089995118
     :END:
***** Text
      /Polymorphism/ in Haskell means being able to write code in terms of {{c1::values
      which may be one of several, or any, type}}.
***** Extra
**** arity
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1547089995168
     :END:
***** Text
      /Arity/ is the {{c1::number of arguments a function accepts}}. This notion
      is a little slippery in Haskell {{c1::due to currying}}, as all functions are
      {{c1::1-arity}}.
***** Extra
**** type alias in haskell
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1547089995219
     :END:
***** Text
      A /type alias/ is a way to refer to a {{c1::type constructor}} or {{c1::type constant}} by an
      alternate name, usually to {{c1::communicate something more specific or for
      brevity}}.
***** Extra
**** type constructor
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1547926855600
     :END:
***** Text
      /Type constructors/ in Haskell are {{c1::*not values* and can only be used in type
      signatures}}. Type constructors are used to {{c1::denote the type being declared
      by a data declaration}}.
***** Extra
**** Type Signature Example
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1547066838858
     :END:
***** Front
      In the snippet below:
      #+BEGIN_SRC haskell
        type Name = String  
        data Pet = Cat | Dog Name
      #+END_SRC
      What are the type signatures of the data constructors?
***** Back
      #+BEGIN_SRC haskell
        Cat :: Pet
        Dog :: Name -> Pet
      #+END_SRC
**** Data & Type Constructors Example
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1547066838858
     :END:
***** Front
      In the snippet below:
      #+BEGIN_SRC haskell
        type Name = String  
        data Pet = Cat | Dog Name
      #+END_SRC
      What is/are the type and data constructors?
***** Back
      =Pet= is the /type constructor/ and both =Cat= and =Dog Name= are /Data
      Constructors/ for the type =Cat=.
**** Data Constructors
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1547066513606
     :END:
***** Text
      {{c1::/Data constructors/}} in Haskell provide a means of {{c2::creating
      values that inhabit a given type}}. {{c1::Data constructors}} in Haskell
      have a {{c1::type}} and can either be {{c2::constant values (nullary)}} or
      {{c2::take one or more arguments, like functions}}.
***** Extra
**** Type Class
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1547066513631
     :END:
***** Text
      a {{c1::/Type Class/}} is a set of {{c2::operations defined with respect to
      a polymorphic type}}. When a type has an instance of a {{c1::type class}},
      {{c2::values of that type can be used in the standard operations}} defined
      for that {{c1::type class}}.
***** Extra
**** Tuple
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1547066513656
     :END:
***** Text
      a /Tuple/ is an {{c1::ordered group of values}}. In Haskell, you cannot
      have a tuple with {{c1::only one element}}, but there is a zero tuple also
      {{c1::called /unit/ or =()=}}.
***** Extra
*** CH5
*** CH6
*** CH7
** discrete
   :PROPERTIES:
   :ANKI_DECK: discrete
   :END:
*** graphs
**** def of graph 
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546828409936
     :END:
***** Front
      Definition of Graph
***** Back
      a graph $G = (V,E)$ consists of a set of a set $V$ of vertices and a set $E$ of
      edges such that each $e \in E$ is associated with an unordered pair of
      vertices, $e = (v, w)$.
**** dir graph
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546828488911
     :END:
***** Front
      Definition of Directed Graph
***** Back
     a graph $G = (V,E)$ consists of a set of a set $V$ of vertices and a set $E$ of
     edges such that each $e \in E$ is associated with an $\textbf{ordered}$ pair of
     vertices where $e = (v, w)$ denotes a unique edge $e$ from $v$ to $w$.
**** simple graph
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546828488961
     :END:
***** Front
      Definition of a Simple Graph
***** Back
      $G = (V, E)$ that has neither loops nor parallel edges.
**** path
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546828489011
     :END:
***** Front
      Definition of Path
***** Back
      Finite or infinite sequence of vertices $v_{0}, v_{1}, ..., v_{n}$ that
      are connected and "traveled" within a graph. Its length is always $n - 1$,
      the number of edges traveled. In a weighted graph, it is the
      $\textbf{sum}$ of the weights of the edges traveled.
**** weighted G
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546828489061
     :END:
***** Front
      Definition of weighted Graph
***** Back
     a graph $G = (V,E)$ where all $e \in E$ there is a real number $w(e)$
     called its "weight."
*** trees
**** Tree [9.1.1]
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546828534486
     :END:
***** Front
      Definition of a Tree, Free and Rooted.
***** Back
      A (free) tree $T$ is a simple graph where $v$ and $w$ are vertices in $T$,
      there exists a unique path from $v$ to $w$.

      $T$ is a *rooted* tree where a particular vertex is designated the *root*.
**** Level of a vertex
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546828534535
     :END:
***** Front
      The level of a vertex in a Tree?
***** Back
      The level of a vertex $v$ is the length of the simple path from the root
      $v_{0}$ to $v_{n}$. Level is also known as *Depth* and runs opposite of a
      Tree's Height.
      #+BEGIN_EXPORT html
        <img src="https://user-images.githubusercontent.com/18218174/47659697-7e2e2a00-db63-11e8-97bc-5e961a19dfff.png"/>
      #+END_EXPORT
**** Height of a vertex
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546828534586
     :END:
***** Front
      The height of a vertex?
***** Back
      The height of a vertex is the longest simplest path from the vertex $v$ and
      a tree's leaf. A *tree's height* is the longest simplest path from root to
      a leaf or, equivalently, the maximum level that occurs in the tree.
      #+BEGIN_EXPORT html
        <img src="https://user-images.githubusercontent.com/18218174/47659697-7e2e2a00-db63-11e8-97bc-5e961a19dfff.png"/>
      #+END_EXPORT
**** Parent of Vertex [9.2.1]
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546828534638
     :END:
***** Front
      Definition of parent vertex in a tree $T$?
***** Back
      Let $T$ be a tree with root $v_{0}$. Suppose that $x$, $y$, and $z$ are
      vertices in $T$ and that $(v_{0}, v_{1}, ..., v_{n})$ is a simple path in
      $T$. Then:

      $v_{n - 1}$ is the parent of $v_{n}$
**** Ancestors of Vertex [9.2.1]
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546828534786
     :END:
***** Front
      Definition of a vertex's ancestors in tree $T$?
***** Back
      Let $T$ be a tree with root $v_{0}$. Suppose that $x$, $y$, and $z$ are
      vertices in $T$ and that $(v_{0}, v_{1}, ..., v_{n})$ is a simple path in
      $T$. Then:

      $v_{0}, ..., v_{n - 1}$ are the ancestors of $v_{n}$.
**** Descendant of Vertex [9.2.1]
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546828574612
     :END:
***** Front
      Definition of a vertex's descendants in tree $T$?
***** Back
      Let $T$ be a tree with root $v_{0}$. Suppose that $x$, $y$, and $z$ are
      vertices in $T$ and that $(v_{0}, v_{1}, ..., v_{n})$ is a simple path in
      $T$. Then:

      If $x$ is an ancestor of $y$, then $y$ is a *descendant* of $x$.
**** Siblings of Vertex [9.2.1]
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546828574662
     :END:
***** Front
      Definition of a vertex's siblings?
***** Back
      Let $T$ be a tree with root $v_{0}$. Suppose that $x$, $y$, and $z$ are
      vertices in $T$ and that $(v_{0}, v_{1}, ..., v_{n})$ is a simple path in
      $T$. Then:

      If $x$ and $y$ are children of $z$, then $x$ and $y$ are *siblings*.
**** Terminal Vertex [9.2.1]
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546828574710
     :END:
***** Front
      Definition of terminal(leaf) vertex?
***** Back
      Let $T$ be a tree with root $v_{0}$. Suppose that $x$, $y$, and $z$ are
      vertices in $T$ and that $(v_{0}, v_{1}, ..., v_{n})$ is a simple path in
      $T$. Then:

      If $x$ has no children then $x$ is a *terminal* vertex, aka *leaf*.
**** Internal Vertex [9.2.1]
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546828574761
     :END:
***** Front
      Definition of an internal vertex?
***** Back
      Let $T$ be a tree with root $v_{0}$. Suppose that $x$, $y$, and $z$ are
      vertices in $T$ and that $(v_{0}, v_{1}, ..., v_{n})$ is a simple path in
      $T$. Then:

      If $x$ has children, then $x$ is an *internal* vertex, aka *branch*.
**** Subtree of a tree[9.2.1]
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546828574811
     :END:
***** Front
      Definition of a subtree?
***** Back
      Let $T$ be a tree with root $v_{0}$. Suppose that $x$, $y$, and $z$ are
      vertices in $T$ and that $(v_{0}, v_{1}, ..., v_{n})$ is a simple path in
      $T$. Then:

      The *subtree* of $T$ rooted at $x$ is the graph with vertex set $V$ and edge set $E$,
      where $V$ is $x$ together with the descendants of $x$ and $E = {e | e
      \text{ is an edge on a simple path from } x \text{ to some vertex in } V}$
**** Definitional Equivalents of trees [9.2.3]
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546828574861
     :END:
***** Front
      Different definitions of a tree, $T$?
***** Back
      Let $T$ be a graph with $n$ vertices. The following are equivalent for $T$:
      1. is a tree.
      2. is *connected* and *acyclic*.
      3. is *connected* and has $n - 1$ edges.
      4. is *acyclic* and has $n - 1$ edges.
**** Spanning Tree [9.3.1]
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546828650511
     :END:
***** Front
      Definition of spanning tree?
***** Back
      a tree $T$ is a *spanning tree* of a graph $G$ if $T$ is a subgraph of $G$
      that contains all the vertices of $G$

      In the image below, the black lines mark the edges included in the spanning
      tree of $G$:

      #+BEGIN_EXPORT html
        <img src="https://user-images.githubusercontent.com/18218174/47662600-38746000-db69-11e8-9b74-c4b4d7ee452b.jpg"/>
      #+END_EXPORT
**** Spanning Tree <=> Connected [9.3.4]
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1546828650561
     :END:
***** Text
      A graph $G$ has a spanning tree if and only if {{c1::$G$ is connected.}}
***** Extra
**** Breadth-First Description 
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1546828650611
     :END:
***** Text
      Breadth-First Search (BFS) is an algorithm for traversing {{c1::tree or graph data structures}}
      by starting at some root and explores {{c1::all neighbor nodes at the present
      depth}} before {{c1::moving to the next level}}.
***** Extra
**** Depth-First Description
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1546828650651
     :END:
***** Text
      Depth-First Search (DFS) is an algorithm for traversing {{c1::tree or graph data
      structures.}} It starts at some node and explores{{c1:: as far as possible along
      each branch}} before {{c1::backtracking}}.
***** Extra
**** Minimal Spanning Tree [9.4.1]
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546829177961
     :END:
***** Front
      Definition of a Minimum Spanning Tree of graph $G$?
***** Back
      Let $G$ be a weighted graph. A *minimal spanning tree* of $G$ is a spanning tree
      of *G* with minimum weight.
**** Prim's Algo Description
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1546829178012
     :END:
***** Text
      Prim's algorithm is a greedy algorithm that {{c1::finds a minimum spanning tree
      for a weighted undirected graph}} by starting {{c1::from an arbitrary vertex}} and
      {{c1::incrementally adding the cheapest possible connection from the tree}} to
      another vertex without {{c1::forming a complete cycle.}}
***** Extra
**** Kruskal's Algo Description
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1546829178035
     :END:
***** Text
      Kruskal's algorithm is a greedy algorithm that {{c1::finds a minimum spanning
      tree $T$ for a weighted undirected graph $G$}} by starting {{c1::with all vertices of $G$}} and
      no edges, incrementally adding {{c1::the lowest cost edge $e$ to $T$ without
      forming a complete cycle}}.
***** Extra
**** Definition of Binary Tree [9.5.1]
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546829178186
     :END:
***** Front
      Definition of a Binary Tree?
***** Back
      A *Binary Tree* is a rooted tree in which each vertex has either no
      children, one child, or two children.
**** Full Binary Tree and # Leaves, Total Vertices [9.5.4]
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1546829214911
     :END:
***** Text
      If $T$ is a *full* binary tree with $i$ internal vertices, then $T$ has {{c1::$i + 1$}}
      terminal vertices (leaves) and {{c1::$2i + 1$}} total vertices.
***** Extra
**** Relation between height and leaves in Binary Tree [9.5.6]
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Cloze
     :ANKI_NOTE_ID: 1546829214961
     :END:
***** Text
      If a binary tree of height $h$ has $t$ terminal (leaf) vertices, then {{c1::$\lg
      t \leq  h$.}}
***** Extra
**** Definition of Binary Search Tree [9.5.8]
     :PROPERTIES:
     :ANKI_NOTE_TYPE: Basic
     :ANKI_NOTE_ID: 1546829215112
     :END:
***** Front
      Definition of a Binary Search Tree?
***** Back
      A binary search tree is a binary tree $T$ in which data are associated with
      the vertices. The data are arranged so that, for each vertex $v$ in $T$,
      each data item in the left subtree of $v$ is less than the data item in
      $v$, and each data item in the right subtree of $v$ is greater than the
      data item in $v$.
** PL Theory and Design
   :PROPERTIES:
   :ANKI_DECK: pl
   :END:
*** Declarative vs Imperative                                           
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Basic
    :ANKI_NOTE_ID: 1535396788649
    :END:
**** Front
     What is the difference between declarative and imperative languages?
**** Back
     Declarative vs Imperative is the topmost level of distinction between types
     of PLs. 

      - Imperative languages focus on /how/ a computer goes about its instructed
        task.

      - Declarative languages focus on /what/ the computer does.
*** Types of Declarative PLs                                            
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Basic
    :ANKI_NOTE_ID: 1535396788699
    :END:
**** Front
     What are the types of Declarative PLs?
**** Back
     1. Functional -> Lisp, ML, Haskell
     2. Logic, Constraint Based -> Prolog, Spreadsheets, SQL
     3. Dataflow -> Id, Val
*** Types of Imperative PLs                                             
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Basic
    :ANKI_NOTE_ID: 1535396788724
    :END:
**** Front
     What are the types of Imperative PLs?
**** Back
     1. von Neumann -> C, Ada, Fortran
     2. OOP -> Smalltalk, Eiffel, Java
     3. Scripting -> Perl, Python, PHP
*** General Compilation Process                                         
    :PROPERTIES:
    :ANKI_NOTE_TYPE: Basic
    :ANKI_NOTE_ID: 1535396788874
    :END:
**** Front
     What are the steps of the compilation process?
**** Back
     1. scanner (lexical analysis)
     2. parser (syntax analysis)
     3. semantic analysis & intermediate code generation
     4. machine independent code improvement (*optional*)
     5. target code generation (assembler)
     6. machine-specific code improvement (*optional*) 
